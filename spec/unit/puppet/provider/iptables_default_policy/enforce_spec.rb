require 'spec_helper'

provider_type = Puppet::Type.type(:iptables_default_policy)
provider_class = provider_type.provider(:enforce)

describe provider_class do
  before(:each) do
    Facter.clear

    allow(Facter).to receive(:value).with(:ipv6_enabled).and_return true

    @path = ENV['PATH'].split(':').first

    allow(FileTest).to receive(:file?).with(File.join(@path,'iptables')).and_return true
    allow(FileTest).to receive(:exist?).with(File.join(@path,'iptables')).and_return true
    allow(FileTest).to receive(:executable?).with(File.join(@path,'iptables')).and_return true

    allow(FileTest).to receive(:file?).with(File.join(@path,'iptables-save')).and_return true
    allow(FileTest).to receive(:exist?).with(File.join(@path,'iptables-save')).and_return true
    allow(FileTest).to receive(:executable?).with(File.join(@path,'iptables-save')).and_return true

    allow(FileTest).to receive(:file?).with(File.join(@path,'ip6tables')).and_return true
    allow(FileTest).to receive(:exist?).with(File.join(@path,'ip6tables')).and_return true
    allow(FileTest).to receive(:executable?).with(File.join(@path,'ip6tables')).and_return true

    allow(FileTest).to receive(:file?).with(File.join(@path,'ip6tables-save')).and_return true
    allow(FileTest).to receive(:exist?).with(File.join(@path,'ip6tables-save')).and_return true
    allow(FileTest).to receive(:executable?).with(File.join(@path,'ip6tables-save')).and_return true

    @iptables_rules = <<-EOM
# Generated by iptables-save
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:TEST - [0:0]
-A PREROUTING -m addrtype --dst-type LOCAL -j TEST
COMMIT
# Generated by iptables-save
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
COMMIT
# Generated by iptables-save
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:TEST - [0:0]
COMMIT
# Generated by iptables-save
*security
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:FORWARD_direct - [0:0]
:INPUT_direct - [0:0]
:OUTPUT_direct - [0:0]
-A INPUT -j INPUT_direct
-A FORWARD -j FORWARD_direct
-A OUTPUT -j OUTPUT_direct
COMMIT
# Generated by iptables-save
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
:TEST - [0:0]
-A IN_public_allow -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW,UNTRACKED -j ACCEPT
COMMIT
    EOM

    allow(provider_class).to receive(:iptables_rules).and_return @iptables_rules.lines.map(&:strip)
    allow(provider_class).to receive(:ip6tables_rules).and_return @iptables_rules.lines.map(&:strip)
  end

  it 'should list valid instances' do
    inst = provider_class.instances.map { |p|
      {
        :name     => p.get(:name),
        :table    => p.get(:table),
        :chain    => p.get(:chain),
        :policy   => p.get(:policy),
        :apply_to => p.get(:apply_to)
      }
    }

    to_comp = [
      {
        :name     => 'filter:INPUT',
        :table    => 'filter',
        :chain    => 'INPUT',
        :policy   => 'ACCEPT',
        :apply_to => 'ipv4'
      },
      {
        :name     => 'filter:FORWARD',
        :table    => 'filter',
        :chain    => 'FORWARD',
        :policy   => 'DROP',
        :apply_to => 'ipv4'
      },
      {
        :name     => 'filter:OUTPUT',
        :table    => 'filter',
        :chain    => 'OUTPUT',
        :policy   => 'ACCEPT',
        :apply_to => 'ipv4'
      }
    ]

    to_comp.dup.each do |entry|
      new_entry = entry.dup
      new_entry[:apply_to] = 'ipv6'

      to_comp << new_entry
    end

    expect(inst).to eq(to_comp)
  end

  context '#flush' do
    context 'ipv4' do
      it 'should update the filter:INPUT chain for ipv4' do
        table = 'filter'
        chain = 'INPUT'
        policy = 'DROP'

        resource = provider_type.new({
          :name     => table + ':' + chain,
          :policy   => policy,
          :apply_to => 'ipv4'
        })

        provider = provider_class.new(resource)

        allow(provider.class).to receive(:iptables).with(
          [
            '-t',
            table,
            '-P',
            chain,
            policy
          ]
        ).and_return true

        allow(provider).to receive(:needs_sync).and_return(['ipv4'])

        expect(provider.class).not_to receive(:ip6tables)

        provider.flush
      end
    end

    context 'ipv6' do
      it 'should update the filter:INPUT chain for ipv6' do
        table = 'filter'
        chain = 'INPUT'
        policy = 'DROP'

        resource = provider_type.new({
          :name     => table + ':' + chain,
          :policy   => policy,
          :apply_to => 'ipv6'
        })

        provider = provider_class.new(resource)

        allow(provider.class).to receive(:ip6tables).with(
          [
            '-t',
            table,
            '-P',
            chain,
            policy
          ]
        ).and_return true

        allow(provider).to receive(:needs_sync).and_return(['ipv6'])

        expect(provider.class).not_to receive(:iptables)

        provider.flush
      end
    end

    context 'both' do
      it 'should update the filter:INPUT chain for ipv4 and ipv6' do
        table = 'filter'
        chain = 'INPUT'
        policy = 'DROP'

        resource = provider_type.new({
          :name     => table + ':' + chain,
          :policy   => policy,
          :apply_to => 'all'
        })

        provider = provider_class.new(resource)

        allow(provider.class).to receive(:ip6tables).with(
          [
            '-t',
            table,
            '-P',
            chain,
            policy
          ]
        ).and_return true

        allow(provider.class).to receive(:iptables).with(
          [
            '-t',
            table,
            '-P',
            chain,
            policy
          ]
        ).and_return true

        allow(provider).to receive(:needs_sync).and_return(['ipv4', 'ipv6'])

        provider.flush
      end
    end
  end
end
